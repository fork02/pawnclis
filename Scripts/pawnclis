#!/bin/bash

# {Project Scripts} : "pawnclis" - for Linux
# {Copyright} GNU GPL Version 3, 29 June 2007 ("maintainers") ("2025")

if [ ! -f "data.json" ]; then
    cat > data.json <<EOF
{
    "amx_opt": "-d0",
    "allow_subdir": "/pawno/include",

    "ppm_dir": "pawno",
    "ppm_subdir": "include",
    "ppm_type": "urllib3",

    "chatbot_token": "",
    "chatbot_model": "",
    "chatbot_biodata": "",
    "chatbot_json_get": ""
}
EOF
fi

##################################################################
AMX_OPT_F=$(grep '"amx_opt"' data.json | sed -E 's/.*"amx_opt": "(.*)".*/\1/')
##################################################################

# @pawn-lang compiler 3.10.7^ - ("https://github.com/pawn-lang/compiler")

# Usage:   pawncc <filename> [filename...] [options]
# Options:
#        -A<num>  alignment in bytes of the data segment and the stack
#        -a       output assembler code
#        -C[+/-]  compact encoding for output file (default=+)
#        -c<name> codepage name or number; e.g. 1252 for Windows Latin-1
#        -Dpath   active directory path
#        -d<num>  debugging level (default=-d1)
#            0    no symbolic information, no run-time checks
#            1    run-time checks, no symbolic information
#            2    full debug information and dynamic checking
#            3    same as -d2, but implies -O0
#        -e<name> set name of error file (quiet compile)
#        -H<hwnd> window handle to send a notification message on finish
#        -i<name> path for include files
#        -l       create list file (preprocess only)
#        -o<name> set base name of (P-code) output file
#        -O<num>  optimization level (default=-O1)
#            0    no optimization
#            1    JIT-compatible optimizations only
#            2    full optimizations
#        -p<name> set name of "prefix" file
#        -R[+/-]  add detailed recursion report with call chains (default=-)
#        -r[name] write cross reference report to console or to specified file
#        -S<num>  stack/heap size in cells (default=4096)
#        -s<num>  skip lines from the input file
#        -t<num>  TAB indent size (in character positions, default=8)
#        -v<num>  verbosity level; 0=quiet, 1=normal, 2=verbose (default=1)
#        -w<num>  disable a specific warning by its number
#        -X<num>  abstract machine size limit in bytes
#        -XD<num> abstract machine data/stack size limit in bytes
#        -Z[+/-]  run in compatibility mode (default=-)
#        -E[+/-]  turn warnings in to errors
#        -\       use '\' for escape characters
#        -^       use '^' for escape characters
#        -;[+/-]  require a semicolon to end each statement (default=-)
#        -([+/-]  require parantheses for function invocation (default=-)
#        sym=val  define constant "sym" with value "val"
#        sym=     define constant "sym" with value 0

if [ ! -d .cache ]; then
    mkdir .cache
fi

_DIR1=$(awk -F'"' '/"ppm_dir"/ {print $4}' data.json)
_DIR2=$(awk -F'"' '/"ppm_subdir"/ {print $4}' data.json)

ALLOW_INC_DIR="$_DIR1/$_DIR2"

METADAT_FILE=".cache/compiler.log"

SHUSERS="$USER@$(hostname)"

bash_title() {
    echo -ne "\033]0;$1\007"
}

bash_title "$SHUSERS:~"

BASH_DIR="$(dirname "$0")"
BASH_TITLE=""
BASH_NAME="pawnclis"
BASH_SERVER="samp03svr"
BASH_BUILD="0.0.1-b4"

BASH_ALLOW_SDIR=$(grep '"allow_subdir"' data.json | sed -E 's/.*"allow_subdir": "(.*)".*/\1/')

COMPILER_MODE=false
BASH_SEND_SAMP_STATUS=0
BASH_SEND_PAWNCC_STATUS=0
COMPILER_PAWNCC=""

# "https://groq.com/"
CHATBOT_TOKEN=$(grep '"chatbot_token"' data.json | sed -E 's/.*"chatbot_token": "(.*)".*/\1/')
CHATBOT_MODEL=$(grep '"chatbot_model"' data.json | sed -E 's/.*"chatbot_model": "(.*)".*/\1/')
CHATBOT_BIODATA=$(grep '"chatbot_biodata"' data.json | sed -E 's/.*"chatbot_biodata": "(.*)".*/\1/')
CHATBOT_JSON_GET=$(grep '"chatbot_json_get"' data.json | sed -E 's/.*"chatbot_json_get": "(.*)".*/\1/')
    # "python3"
    # "sed"
    # "jq"
    # "grep"

PPM_INSTALLER=$(grep '"ppm_type"' data.json | sed -E 's/.*"ppm_type": "(.*)".*/\1/')
    # "urllib3"
    # "curl"
    # "requests"
    # "pycurl"

URL_DOWNLOAD="https://raw.githubusercontent.com/vilksons/pawnclis/refs/heads/main/Scripts/pawnclis"

COLOR_Y="\e[33m"
COLOR_G="\e[32m"
COLOR_R="\e[91m"

function bash_coltext_y() {
    local color="$COLOR_Y"
    local text="$1"
    echo -e "${color}${text}\e[0m"
}

function bash_coltext_g() {
    local color="$COLOR_G"
    local text="$1"
    echo -e "${color}${text}\e[0m"
}

function bash_coltext_r() {
    local color="$COLOR_R"
    local text="$1"
    echo -e "${color}${text}\e[0m"
}

function bash_typeof() {
    COMPILER_MODE=false
    BASH_SEND_SAMP_STATUS=0
    BASH_SEND_PAWNCC_STATUS=0
    COMPILER_PAWNCC=""

    echo -n "$(bash_coltext_y "$SHUSERS")"
    echo -n ":~$ "
    read -r OPBASH_F
    bash_next
}

function bash_typeof2() {
    echo -n "$(bash_coltext_y "$SHUSERS")"
    echo -n ":~$ "
    read -r OPBASH_PF
    packageManager
}

bash_next() {
    local BASH_OPTION="paw"

    case "$OPBASH_F" in
        "$BASH_OPTION -c" | "compile")
            BASH_TITLE="compilator"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            killall -15 "samp03svr" >/dev/null 2>&1
            echo
            COMPILER_MODE=true
            bash_compilers
            ;;
        "$BASH_OPTION -r" | "running")
            BASH_TITLE="running"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            killall -15 "samp03svr" >/dev/null 2>&1
            sleep 0
            bash_servers
            ;;
        "$BASH_OPTION -d" | "debugg")
            BASH_TITLE="samp server debugger"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            bash_testservers
            ;;
        "$BASH_OPTION -s" | "stop")
            BASH_TITLE="stopped server"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            killall -15 "samp03svr" >/dev/null 2>&1
            bash_end ""
            ;;
        "$BASH_OPTION -t" | "restart")
            BASH_TITLE="restart server"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            if pgrep -x "samp03svr" >/dev/null; then
                killall -15 "samp03svr" >/dev/null 2>&1
                sleep 2
                bash_servers
            else
                echo "sa-mp server in running not found."
            fi
            ;;
        "$BASH_OPTION -u" | "compilerunn")
            BASH_TITLE="compile running"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            killall -15 "samp03svr" >/dev/null 2>&1

            COMPILER_MODE=false

            echo
            compilers
            if grep -i "error" "$METADAT_FILE" >/dev/null; then
                echo
            else
                ok_next
            fi
            ;;
        "$BASH_OPTION -g" | "gamemode")
            BASH_TITLE="download gamemode"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            BASH_SEND_SAMP_STATUS=0

            while true; do
                echo "Linux/Windows [a/b]"
                read -r -p ">> " SEL_CO
                case "$SEL_CO" in
                    [Aa])
                        bash_send_samp
                        break
                        ;;
                    [Bb])
                        bash_send_samp2
                        break
                        ;;
                    *)
                        echo -n "$(bash_coltext_r "E: ")"
                        echo "Invalid selection. Please enter A or B."
                        ;;
                esac
            done
            bash_end ""
            ;;
        "$BASH_OPTION -p" | "pawncc")
            BASH_TITLE="download pawncc"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            BASH_SEND_PAWNCC_STATUS=0

            while true; do
                echo "Linux/Windows [a/b]"
                read -r -p ">> " SEL_CO
                case "$SEL_CO" in
                    [Aa])
                        bash_send_compiler
                        break
                        ;;
                    [Bb])
                        bash_send_compiler2
                        break
                        ;;
                    *)
                        echo -n "$(bash_coltext_r "E: ")"
                        echo "Invalid selection. Please enter A or B."
                        ;;
                esac
            done

            bash_end ""
            ;;
        "$BASH_OPTION -C" | "clear")
            BASH_TITLE="clear screen"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            clear
            bash_typeof ""
            ;;
        "$BASH_OPTION -V" | "tasks")
            BASH_TITLE="vscode tasks"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            if [ -d ".vscode" ]; then
                rm -rf .vscode
            fi
            mkdir .vscode
            cat <<EOF > .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Run PawnCLIS",
      "type": "process",
      "command": "\${workspaceFolder}/$BASH_NAME",
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": [],
      "detail": "Task to run the PawnCLIS"
    }
  ]
}
EOF
            echo "OK? '.vscode/tasks.json'...: [yes]"
            bash_end ""
            ;;
        "$BASH_OPTION -F" | "check")
            BASH_TITLE="folder check"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            CHECK_FOL_NOW "filterscripts"
            CHECK_FOL_NOW "gamemodes"
            CHECK_FOL_NOW "scriptfiles"
            if [ -f "server.cfg" ]; then
                echo
                echo "# server.cfg is .. Ok .."
                echo " [A subdirectory or file server.cfg already exists.]"
            else
                cat <<EOF > server.cfg
echo Executing Server Config...
lanmode 0
rcon_password changename
maxplayers 150
port 7777
hostname SA-MP 0.3
gamemode0 main 1
filterscripts
announce 0
chatlogging 0
weburl www.sa-mp.com
onfoot_rate 40
incar_rate 40
weapon_rate 40
stream_distance 300.0
stream_rate 1000
maxnpc 0
logtimeformat [%H:%M:%S]
language English
EOF
                echo "OK? '$BASH_DIR/server.cfg'...: [yes]"
                echo
                cat server.cfg
                echo
                bash_end ""
            fi
            ;;
        "$BASH_OPTION -v" | "version")
            BASH_TITLE="version"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            echo
            echo "~ $BASH_BUILD"
            echo
            bash_end ""
            ;;
        "$BASH_OPTION -T" | "type")
            BASH_TITLE="type files"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            echo -n ":: Enter the file name:"
            read -r -p ">>> " inputTYPES
            cat "$inputTYPES"
            echo
            bash_end ""
            ;;
        "$BASH_OPTION -D" | "directory")
            BASH_TITLE="directory"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            ls
            ;;
        "$BASH_OPTION -K" | "kill")
            BASH_TITLE="kill"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            sleep 0

            chmod +x $BASH_NAME
            bash ./$BASH_NAME
            ;;
        "$BASH_OPTION -U" | "update")
            BASH_TITLE="Update PawnCLIS"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            cd "$BASH_DIR" || bash_end ""
            curl -L --progress-bar -o "$BASH_NAME" "$URL_DOWNLOAD"
            clear
            chmod +x $BASH_NAME
            bash ./$BASH_NAME
            ;;
        "$BASH_OPTION -S" | "checksums")
            BASH_TITLE="Checksums"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            cd "$BASH_DIR" || bash_end ""
            sha1sum $BASH_NAME
            sha256sum $BASH_NAME
            md5sum $BASH_NAME
            ;;
        "$BASH_OPTION -W" | "whoami")
            BASH_TITLE="whoami"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            whoami
            bash_end ""
            ;;
        "$BASH_OPTION -e" | "exit")
            BASH_TITLE="exit"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            sleep 0

            bash
            ;;
        "$BASH_OPTION -a" | "chatbot")
            BASH_TITLE="chatbot"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            echo -n ":: Enter the Question:"
            echo
            read -r -p ">>> " user_question
    
            if [[ "$user_question" == "exit" ]]; then
                echo "..close."
                bash_end ""
            fi

            echo "*typing..."

            response=$(curl -s -X POST https://api.groq.com/openai/v1/chat/completions \
                -H "Authorization: Bearer $CHATBOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                    \"model\": \"$CHATBOT_MODEL\",
                    \"messages\": [
                        {
                        \"role\": \"system\",
                        \"content\": \"$CHATBOT_BIODATA\"
                        },
                        {
                        \"role\": \"user\",
                        \"content\": \"$user_question\"
                        }
                    ],
                    \"temperature\": 1,
                    \"max_tokens\": 1024,
                    \"top_p\": 1,
                    \"stream\": false,
                    \"stop\": null
                    }")

            if [ "$CHATBOT_JSON_GET" == "python3" ]; then
                echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin)['choices'][0]['message']['content'])"
            elif [ "$CHATBOT_JSON_GET" == "sed" ]; then
                echo "$response" | sed -E 's/.*"content":"([^"]*)".*/\1/' | awk '{gsub(/\\n/, "\n")}1'
            elif [ "$CHATBOT_JSON_GET" == "jq" ]; then
                echo "$response" | jq -r '.choices[0].message.content'
            elif [ "$CHATBOT_JSON_GET" == "grep" ]; then
                echo "$response" | grep -oP '"content":"\K[^"]*'
            fi
            
            echo "----------------------------------"
            bash_end ""
            ;;
        "$BASH_OPTION -N" | "nano")
            BASH_TITLE="GNU Nano Editor"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            echo ":: Enter the File:"
            read -r -p ">>> " FILE_PATH
            nano "$FILE_PATH"
            bash_typeof ""
            ;;
        "$BASH_OPTION -M" | "ppm")
            bash_typeof2 ""
            ;;
        "help")
            BASH_TITLE="help"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            bash_help
            bash_typeof ""
            ;;
        "$BASH_OPTION")
            bash_help
            bash_typeof ""
            ;;
        "")
            bash_typeof ""
            ;;
        " ")
            bash_typeof ""
            ;;
        *)
            echo "not found!. please use 'help'"
            bash_typeof ""
            ;;
    esac
}

packageManager()
{
    local PACMAN="ppm"

    case "$OPBASH_PF" in
        "$PACMAN -S" | "install")
            BASH_TITLE="PawnCLIS Package Manager (Sync)"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            local PPM_PLUGIN_DIR="plugins"
            local _PPM_PACKAGE_FILE="package.json"
            local PPM_SERVER_CFG="server.cfg"

            if [ ! -d "$_DIR1" ]; then
                mkdir -p "$ALLOW_INC_DIR"
            fi

            if [ ! -f "$_PPM_PACKAGE_FILE" ]; then
                echo -n "$(bash_coltext_r "E: ")"
                echo "package.json not found"
                
                cat > package.json <<EOF
{
    "package": [
        "github/example/user/repository",
        "github/example/user/repository/to/files/.zip",
        "github/example/user/repository/to/files/.tar.gz",
        "gitlab/example/user/repository",
        "gitlab/example/user/repository/to/files/.zip",
        "gitlab/example/user/repository/to/files/.tar.gz"
    ]
}
EOF

                bash_typeof2 ""
            fi

            PPM_URLS=$(awk -F '"' '/package/ {getline; while ($0 ~ /"/) {print $2; getline}}' "$_PPM_PACKAGE_FILE")

            for PPM_REPOSITORY_URL in $PPM_URLS; do
                echo -n "$(bash_coltext_y "info: ")"
                echo "Processing repository: $PPM_REPOSITORY_URL..."

                if [[ "$PPM_REPOSITORY_URL" != https://* ]]; then
                    if [[ "$PPM_REPOSITORY_URL" == github/* ]]; then
                        PPM_REPOSITORY_URL="https://github.com/${PPM_REPOSITORY_URL#github/}"
                    elif [[ "$PPM_REPOSITORY_URL" == gitlab/* ]]; then
                        PPM_REPOSITORY_URL="https://gitlab.com/${PPM_REPOSITORY_URL#gitlab/}"
                    elif [[ "$PPM_REPOSITORY_URL" == sourceforge/* ]]; then
                        PPM_REPOSITORY_URL="https://sourceforge.net/projects/${PPM_REPOSITORY_URL#sourceforge/}"
                    fi
                fi
                
                if [[ "$PPM_REPOSITORY_URL" == *"/releases/download/"* ]]; then
                    PPM_ARCHIVE_URL="$PPM_REPOSITORY_URL"
                elif [[ "$PPM_REPOSITORY_URL" == *"/releases/tag/"* ]]; then
                    PPM_REPO_NAME=$(echo "$PPM_REPOSITORY_URL" | awk -F '/' '{print $(NF-3) "/" $(NF-2)}')
                    PPM_TAG_VERSION=$(echo "$PPM_REPOSITORY_URL" | awk -F '/' '{print $NF}')
                
                    if [[ "$PPM_REPOSITORY_URL" == *"github.com"* ]]; then
                        PPM_API_URL="https://api.github.com/repos/$PPM_REPO_NAME/git/refs/tags/$PPM_TAG_VERSION"
                    elif [[ "$PPM_REPOSITORY_URL" == *"gitlab.com"* ]]; then
                        PPM_API_URL="https://gitlab.com/api/v4/projects/$(echo "$PPM_REPO_NAME" | tr '/' '%2F')/releases/$PPM_TAG_VERSION"
                    elif [[ "$PPM_REPOSITORY_URL" == *"sourceforge.net"* ]]; then
                        PPM_API_URL="https://sourceforge.net/projects/$PPM_REPO_NAME/files/latest/download"
                    else
                        echo "Unsupported repository host."
                        exit 1
                    fi
                
                    [[ -z "$PPM_ARCHIVE_URL" ]] && PPM_ARCHIVE_URL=$(curl -s "$PPM_API_URL" | grep "browser_download_url" | grep -E ".zip|.tar.gz" | awk -F '"' '{print $4}' | head -n 1)
                else
                    PPM_REPO_NAME=$(echo "$PPM_REPOSITORY_URL" | awk -F '/' '{print $(NF-1) "/" $NF}')
                
                    if [[ "$PPM_REPOSITORY_URL" == *"github.com"* ]]; then
                        PPM_API_URL="https://api.github.com/repos/$PPM_REPO_NAME/releases/latest"
                    elif [[ "$PPM_REPOSITORY_URL" == *"gitlab.com"* ]]; then
                        PPM_API_URL="https://gitlab.com/api/v4/projects/$(echo "$PPM_REPO_NAME" | tr '/' '%2F')/releases/permalink/latest"
                    elif [[ "$PPM_REPOSITORY_URL" == *"sourceforge.net"* ]]; then
                        PPM_ARCHIVE_URL="https://sourceforge.net/projects/$PPM_REPO_NAME/files/latest/download"
                    else
                        echo "Unsupported repository host."
                        exit 1
                    fi
                
                    [[ -z "$PPM_ARCHIVE_URL" ]] && PPM_ARCHIVE_URL=$(curl -s "$PPM_API_URL" | grep "browser_download_url" | grep -E ".zip|.tar.gz" | awk -F '"' '{print $4}' | head -n 1)
                fi

                PPM_ARCHIVE_FILE=".__temp__.zip"
                PPM_EXTRACT_DIR=".__temp__"

                rm -rf "$PPM_EXTRACT_DIR"
                mkdir -p "$PPM_EXTRACT_DIR"

                echo -n "$(bash_coltext_y "info: ")"
                echo "Downloading: $PPM_ARCHIVE_URL..."

                if [ "$PPM_INSTALLER" == "urllib3" ]; then
                    python3 -c "import urllib3; http=urllib3.PoolManager(); r=http.request('GET', '$PPM_ARCHIVE_URL', preload_content=False); f=open('$PPM_ARCHIVE_FILE', 'wb'); [f.write(chunk) for chunk in r.stream(1024)]; f.close(); r.release_conn()"
                elif [ "$PPM_INSTALLER" == "requests" ]; then
                    python3 -c "import requests; r = requests.get('$PPM_ARCHIVE_URL', stream=True); with open('$PPM_ARCHIVE_FILE', 'wb') as f: [f.write(chunk) for chunk in r.iter_content(1024)]"
                elif [ "$PPM_INSTALLER" == "curl" ]; then
                    curl -sL "$PPM_ARCHIVE_URL" -o "$PPM_ARCHIVE_FILE"
                fi

                if file "$PPM_ARCHIVE_FILE" | grep -q "Zip archive data"; then
                    unzip -q "$PPM_ARCHIVE_FILE" -d "$PPM_EXTRACT_DIR"
                elif file "$PPM_ARCHIVE_FILE" | grep -q "gzip compressed data"; then
                    mkdir -p "$PPM_EXTRACT_DIR"
                    tar -xzf "$PPM_ARCHIVE_FILE" -C "$PPM_EXTRACT_DIR" --strip-components=1
                else
                    echo -n "$(bash_coltext_r "E: ")"
                    echo "Downloaded file is not a valid ZIP or TAR.GZ archive"
                    rm -rf "$PPM_ARCHIVE_FILE" "$PPM_EXTRACT_DIR"
                    continue
                fi

                PPM_EXTRACT_SUBDIR=$(find "$PPM_EXTRACT_DIR" -mindepth 1 -maxdepth 1 -type d | head -n 1)
                
                if [[ -d "$PPM_EXTRACT_SUBDIR" ]]; then
                    mv "$PPM_EXTRACT_SUBDIR"/* "$PPM_EXTRACT_DIR/"
                    rm -rf "$PPM_EXTRACT_SUBDIR"
                fi

                echo -n "$(bash_coltext_y "info: ")"
                echo "Extraction Directory.."

                find "$PPM_EXTRACT_DIR" -type f -name "*.inc" | while IFS= read -r inc_file; do
                    rel_path=$(realpath --relative-to="$PPM_EXTRACT_DIR" "$inc_file" 2>/dev/null || echo "$inc_file")

                    if [[ "$rel_path" =~ (^|/)include/ ]]; then
                        rel_path="${rel_path#*include/}"
                    fi

                    if [[ "$rel_path" == */* ]]; then
                        dest_path="$ALLOW_INC_DIR/$(dirname "$rel_path")"
                    else
                        dest_path="$ALLOW_INC_DIR"
                    fi

                    mkdir -p "$dest_path"
                    mv "$inc_file" "$dest_path/"
                done

                find "$PPM_EXTRACT_DIR" -type f \( -name "*.dll" -o -name "*.so" \) -exec mv {} "$PPM_PLUGIN_DIR/" \;

                rm -rf "$PPM_ARCHIVE_FILE" "$PPM_EXTRACT_DIR"
                echo -n "$(bash_coltext_y "info: ")"
                echo "Installation complete for $PPM_REPOSITORY_URL!"
            done

            echo -n "$(bash_coltext_y "[All packages installed]")"
            echo

            mkdir -p "$PPM_PLUGIN_DIR"

            if [ ! -f "$PPM_SERVER_CFG" ]; then
                echo -n "$(bash_coltext_r "E: ")"
                echo "$PPM_SERVER_CFG not found! Creating a new one."
                echo "plugins " > "$PPM_SERVER_CFG"
            fi
            if [ ! -f "$PPM_SERVER_CFG" ]; then
                echo "server.cfg not found! Creating a new one."
                echo "plugins " > "$PPM_SERVER_CFG"
            fi
            if ! grep -q "^plugins " "$PPM_SERVER_CFG"; then
                sed -i '1i plugins ' "$PPM_SERVER_CFG"
            fi

            _EXIST_PLUG=$(grep -oP '(?<=plugins ).*' "$PPM_SERVER_CFG" | tr ' ' '\n' | sort -u)

            PPM_NEW_PLUGINS=()
            for FILE in "$PPM_PLUGIN_DIR"/*.{so,dll}; do
            if [ -e "$FILE" ]; then
                _PPM_PLUGIN_NAME=$(basename "$FILE" | sed 's/\.[^.]*$//')
                if ! echo "$_EXIST_PLUG" | grep -qx "$_PPM_PLUGIN_NAME"; then
                PPM_NEW_PLUGINS+=("$_PPM_PLUGIN_NAME")
                fi
            fi
            done

            if [ ${#PPM_NEW_PLUGINS[@]} -gt 0 ]; then
                PPM_UPDATED_PLUGINS=$(echo "$_EXIST_PLUG" "${PPM_NEW_PLUGINS[@]}" | tr '\n' ' ' | xargs -n1 | sort -u | xargs)
                sed -i "s/^plugins .*/plugins $PPM_UPDATED_PLUGINS/" "$PPM_SERVER_CFG"
                echo "Added new plugins to server.cfg: ${PPM_NEW_PLUGINS[*]}"
            else
                echo -n "$(bash_coltext_y "info: ")"
                echo "No new plugins need to be added."
            fi

            bash_typeof2 ""
            ;;
        "$PACMAN -u" | "update")
            BASH_TITLE="PawnCLIS Package Manager (Updates)"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            local PPM_PLUGIN_DIR="plugins"
            local _PPM_PACKAGE_FILE="package.json"

            if [ ! -d "$_DIR1" ]; then
                mkdir -p "$ALLOW_INC_DIR"
            fi

            if [ ! -f "$_PPM_PACKAGE_FILE" ]; then
                echo -n "$(bash_coltext_r "E: ")"
                echo "package.json not found"
                echo

                cat > package.json <<EOF
{
    "package": [
        "github/example/user/repository",
        "github/example/user/repository/to/files/.zip",
        "github/example/user/repository/to/files/.tar.gz",
        "gitlab/example/user/repository",
        "gitlab/example/user/repository/to/files/.zip",
        "gitlab/example/user/repository/to/files/.tar.gz"
    ]
}
EOF

                bash_typeof2 ""
            fi

            mkdir -p "$PPM_PLUGIN_DIR"

            PPM_URLS=$(awk -F '"' '/package/ {getline; while ($0 ~ /"/) {print $2; getline}}' "$_PPM_PACKAGE_FILE")

            for PPM_REPOSITORY_URL in $PPM_URLS; do
                echo -n "$(bash_coltext_y "info: ")"
                echo "Processing repository: $PPM_REPOSITORY_URL..."

                if [[ "$PPM_REPOSITORY_URL" != https://* ]]; then
                    if [[ "$PPM_REPOSITORY_URL" == github/* ]]; then
                        PPM_REPOSITORY_URL="https://github.com/${PPM_REPOSITORY_URL#github/}"
                    elif [[ "$PPM_REPOSITORY_URL" == gitlab/* ]]; then
                        PPM_REPOSITORY_URL="https://gitlab.com/${PPM_REPOSITORY_URL#gitlab/}"
                    elif [[ "$PPM_REPOSITORY_URL" == sourceforge/* ]]; then
                        PPM_REPOSITORY_URL="https://sourceforge.net/projects/${PPM_REPOSITORY_URL#sourceforge/}/files/latest/download"
                    fi
                fi
                
                if [[ "$PPM_REPOSITORY_URL" == *"/releases/download/"* ]]; then
                    PPM_ARCHIVE_URL="$PPM_REPOSITORY_URL"
                elif [[ "$PPM_REPOSITORY_URL" == *"/releases/tag/"* ]]; then
                    PPM_REPO_NAME=$(echo "$PPM_REPOSITORY_URL" | awk -F '/' '{print $(NF-3) "/" $(NF-2)}')
                    PPM_TAG_VERSION=$(echo "$PPM_REPOSITORY_URL" | awk -F '/' '{print $NF}')

                    if [[ "$PPM_REPOSITORY_URL" == *"github.com"* ]]; then
                        PPM_API_URL="https://api.github.com/repos/$PPM_REPO_NAME/git/refs/tags/$PPM_TAG_VERSION"
                    elif [[ "$PPM_REPOSITORY_URL" == *"gitlab.com"* ]]; then
                        PPM_API_URL="https://gitlab.com/api/v4/projects/$(echo "$PPM_REPO_NAME" | tr '/' '%2F')/releases/$PPM_TAG_VERSION"
                    elif [[ "$PPM_REPOSITORY_URL" == *"sourceforge.net"* ]]; then
                        PPM_API_URL="https://sourceforge.net/projects/$PPM_REPO_NAME/files/latest/download"
                    else
                        echo "Unsupported repository host."
                        exit 1
                    fi
                
                    PPM_ARCHIVE_URL=$(curl -s "$PPM_API_URL" | grep "browser_download_url" | grep -E ".zip|.tar.gz" | awk -F '"' '{print $4}' | head -n 1)
                else
                    PPM_REPO_NAME=$(echo "$PPM_REPOSITORY_URL" | awk -F '/' '{print $(NF-1) "/" $NF}')
                
                    if [[ "$PPM_REPOSITORY_URL" == *"github.com"* ]]; then
                        PPM_API_URL="https://api.github.com/repos/$PPM_REPO_NAME/releases/latest"
                    elif [[ "$PPM_REPOSITORY_URL" == *"gitlab.com"* ]]; then
                        PPM_API_URL="https://gitlab.com/api/v4/projects/$(echo "$PPM_REPO_NAME" | tr '/' '%2F')/releases/permalink/latest"
                    elif [[ "$PPM_REPOSITORY_URL" == *"sourceforge.net"* ]]; then
                        PPM_API_URL="https://sourceforge.net/projects/$PPM_REPO_NAME/files/latest/download"
                    else
                        echo "Unsupported repository host."
                        exit 1
                    fi
                
                    [[ -z "$PPM_ARCHIVE_URL" ]] && PPM_ARCHIVE_URL=$(curl -s "$PPM_API_URL" | grep "browser_download_url" | grep -E ".zip|.tar.gz" | awk -F '"' '{print $4}' | head -n 1)
                fi

                if [[ -z "$PPM_ARCHIVE_URL" ]]; then
                    echo -n "$(bash_coltext_y "info: ")"
                    echo "No release found, downloading source master..."
                    PPM_ARCHIVE_URL="${PPM_REPOSITORY_URL}/archive/refs/heads/master.zip"
                fi

                local PPM_ARCHIVE_FILE=".__temp__"
                local PPM_EXTRACT_DIR=".__temp__"

                rm -rf "$PPM_EXTRACT_DIR"
                mkdir -p "$PPM_EXTRACT_DIR"

                echo -n "$(bash_coltext_y "info: ")"
                echo "Downloading: $PPM_ARCHIVE_URL..."
                
if [ "$PPM_INSTALLER" == "urllib3" ]; then
    python3 -c "
import urllib3

http = urllib3.PoolManager()
r = http.request('GET', '$PPM_ARCHIVE_URL', preload_content=False)

with open('$PPM_ARCHIVE_FILE', 'wb') as f:
    [f.write(chunk) for chunk in r.stream(1024)]

r.release_conn()
"
elif [ "$PPM_INSTALLER" == "requests" ]; then
    python3 -c "
import requests

r = requests.get('$PPM_ARCHIVE_URL', stream=True)

with open('$PPM_ARCHIVE_FILE', 'wb') as f:
    [f.write(chunk) for chunk in r.iter_content(1024)]
"
elif [ "$PPM_INSTALLER" == "curl" ]; then
    curl -sL "$PPM_ARCHIVE_URL" -o "$PPM_ARCHIVE_FILE"
elif [ "$PPM_INSTALLER" == "pycurl" ]; then
    python3 -c "
import pycurl

with open('$PPM_ARCHIVE_FILE', 'wb') as f:
    c = pycurl.Curl()
    c.setopt(c.URL, '$PPM_ARCHIVE_URL')
    c.setopt(c.WRITEDATA, f)
    c.setopt(c.FOLLOWLOCATION, True)
    c.perform()
    c.close()
"
fi

                if file "$PPM_ARCHIVE_FILE" | grep -q "Zip archive data"; then
                    echo "Extracting ZIP file..."
                    unzip -q "$PPM_ARCHIVE_FILE" -d "$PPM_EXTRACT_DIR"
                elif file "$PPM_ARCHIVE_FILE" | grep -q "gzip compressed data"; then
                    echo "Extracting TAR.GZ file..."
                    mkdir -p "$PPM_EXTRACT_DIR"
                    tar -xzf "$PPM_ARCHIVE_FILE" -C "$PPM_EXTRACT_DIR" --strip-components=1
                else
                    echo -n "$(bash_coltext_r "E: ")"
                    echo "Downloaded file is not a valid ZIP or TAR.GZ archive"
                    rm -rf "$PPM_ARCHIVE_FILE" "$PPM_EXTRACT_DIR"
                    continue
                fi

                echo -n "$(bash_coltext_y "info: ")"
                echo "Extraction Directory.."

                find "$PPM_EXTRACT_DIR" -type f -name "*.inc" -exec bash -c '
                    for inc_file; do
                        rel_path=$(realpath --relative-to="$1" "$inc_file" 2>/dev/null || echo "$inc_file")
                        dest_path="$2"

                        if [[ "$rel_path" == include/* ]]; then
                            rel_path="${rel_path#*/}"
                        fi

                        if [[ "$rel_path" == */* ]]; then
                            dest_path="$2/$(dirname "$rel_path")"
                        fi

                        mkdir -p "$dest_path"
                        mv "$inc_file" "$dest_path/"
                    done
                ' _ "$PPM_EXTRACT_DIR" "$ALLOW_INC_DIR" {} +

                find "$PPM_EXTRACT_DIR" -type f \( -name "*.dll" -o -name "*.so" \) -exec mv {} "$PPM_PLUGIN_DIR/" \;

                rm -rf "$PPM_ARCHIVE_FILE" "$PPM_EXTRACT_DIR"
                echo "Update completed for $PPM_REPOSITORY_URL!"
            done

            echo -n "$(bash_coltext_y "[All packages have been updated]")"
            echo 

            bash_typeof2 ""
            ;;
        "$PACMAN -r" | "remove")
            BASH_TITLE="PawnCLIS Package Manager (Remove)"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            local PPM_PLUGIN_DIR="plugins"
            local PPM_SERVER_CFG="server.cfg"

            echo ":: Enter the name pattern of the include/plugin to remove:"
            read -r -p ">>> " REMOVE_PATTERN

            filter_files() {
                local pattern="$1"
                while read -r file; do
                    filename=$(basename "$file")
                    if [[ "$filename" =~ ^$pattern(\.[a-z]+)?$ || "$filename" =~ .*-?$pattern(\.[a-z]+)?$ ]]; then
                        echo "$file"
                    fi
                done
            }

            INC_FILES=$(find "$ALLOW_INC_DIR" -type f -name "*.inc" | filter_files "$REMOVE_PATTERN")

            if [[ -n "$INC_FILES" ]]; then
                echo "$INC_FILES" | xargs rm -rf
                echo -n "$(bash_coltext_y "[OK] ")"
                echo "Removed includes: $INC_FILES"
            else
                echo -n "$(bash_coltext_y "info: ")"
                echo "No matching include files found for pattern: $REMOVE_PATTERN"
            fi

            PLUGIN_FILES=$(find "$PPM_PLUGIN_DIR" -type f \( -name "*.dll" -o -name "*.so" \) | filter_files "$REMOVE_PATTERN")

            if [[ -n "$PLUGIN_FILES" ]]; then
                echo "$PLUGIN_FILES" | xargs rm -rf
                echo -n "$(bash_coltext_y "[OK] ")"
                echo "Removed plugins: $PLUGIN_FILES"
            else
                echo -n "$(bash_coltext_y "info: ")"
                echo "No matching plugins found for pattern: $REMOVE_PATTERN"
            fi

            if [[ -f "$PPM_SERVER_CFG" ]]; then
                if grep -q "^plugins" "$PPM_SERVER_CFG"; then
                    sed -i "/^plugins /s/\b$REMOVE_PATTERN\b//g" "$PPM_SERVER_CFG"
                    sed -i 's/  / /g' "$PPM_SERVER_CFG"
                    sed -i 's/^plugins *$/plugins /' "$PPM_SERVER_CFG"
                    echo -n "$(bash_coltext_y "[OK] ")"
                    echo "Removed $REMOVE_PATTERN from server.cfg"
                else
                    echo -n "$(bash_coltext_y "info: ")"
                    echo "No 'plugins' entry found in server.cfg"
                fi
            fi

            echo -n "$(bash_coltext_y "[OK] ")"
            echo "Removal process completed!"
            echo 
            
            bash_typeof2 ""
            ;;
        "$PACMAN")
            bash_help2
            bash_typeof2 ""
            ;;
        "$PACMAN ")
            bash_help2
            bash_typeof2 ""
            ;;
        "help")
            BASH_TITLE="help"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            bash_help2
            bash_typeof2 ""
            ;;
       "$PACMAN -E" | "end")
            bash_typeof ""
            ;;
        *)
            echo "not found!. please use 'help'"
            bash_typeof2 ""
            ;;
    esac
}

function bash_help()
{
    echo "Usage: paw <command> [<options>...]"
    echo ""
    echo "Commonly used commands can be classified as follows:"
    echo ""
    echo "    Basic Operations:"
    echo "        compile     (-c) | compile        Compile a project."
    echo "        running     (-r) | runnning       Check if a process is running."
    echo "        debugger    (-d) | debugg         Start a debugger server."
    echo "        stop        (-s) | stop           Stop a server."
    echo "        restart     (-t) | restart        Restart a server"
    echo "        compile-run (-u) | compilerunn    Compile and run a project."
    echo "        download-gm (-g) | gamemode       Download a gamemode."
    echo "        download-pc (-p) | pawncc         Download pawncc."
    echo "        clear       (-C) | clear          Clear the screen."
    echo "        checksums   (-S) | tasks          Generate or verify checksums."
    echo "        folder-check(-F) | check          Check a folder's integrity."
    echo "        vscode-tasks(-V) | version        Generate VSCode tasks."
    echo "        type-file   (-T) | type           Display file type."
    echo "        whoami      (-W) | directory      Display current user."
    echo "        kill-cmd    (-K) | updates        Kill a command."
    echo "        directory   (-D) | checksums      Change or display the current directory."
    echo "        version     (-v) | version        Display tool version."
    echo "        update      (-U) | update         Update the tool."
    echo "        exit        (-e) | exit           Exit or start a bash shell."
    echo "        ask-ai      (-a) | chatbot        Ask an AI for assistance."
    echo "        GNU Nano    (-N) | nano           GNU/Linux Nano Editor."
    echo "        enter PPM   (-M) | ppm            Enter PawnCLIS Package Manager Mode."
    echo ""
    echo "    Package Management:"
    echo "        sync        (-S) | install        Synchronize and install/replace packages. (ppm)"
    echo "        update      (-u) | update         Update packages. (ppm)"
    echo "        remove      (-r) | remove         Remove packages. (ppm)"
    echo "        end         (-E) | end            End PawnCLIS Package Manager Mode. (ppm)"
    echo ""
}

function bash_help2()
{
    echo "    Package Management:"
    echo "        sync        (-S) | install    Synchronize and install/replace packages. (ppm)"
    echo "        update      (-u) | update     Update packages. (ppm)"
    echo "        remove      (-r) | remove     Remove packages. (ppm)"
    echo "        end         (-E) | end        End PawnCLIS Package Manager Mode. (ppm)"
    echo ""
}

function bash_end() {
    echo -n "$(bash_coltext_y "Press any key to return.")"
    echo
    read -r -n 1 -s
    bash_typeof ""
}

function bash_servers() {
    if [ -f "$BASH_DIR/server_log.txt" ]; then
        rm -rf "$BASH_DIR/server_log.txt"
    fi
    if [ ! -f "$BASH_SERVER" ]; then
        echo
        echo "# $BASH_SERVER not found.."
        BASH_SEND_SAMP_STATUS=1
        bash_send_samp
    fi
    chmod 777 $BASH_SERVER
    ./samp03svr &
    sleep 2
    if ! pgrep -x "samp03svr" >/dev/null; then
        BASH_TITLE="running - failed"
        bash_title "$SHUSERS:~/ $BASH_TITLE"
        echo
        echo -n "$(bash_coltext_r "# Fail")"
        echo
        if [ -f "server_log.txt" ]; then
            sleep 2
            cat server_log.txt
            echo
        else
            echo "# server_log.txt not found."
        fi
        echo -n "$(bash_coltext_y "# End.")"
        echo
        bash_typeof ""
    else
        echo
        echo -n "$(bash_coltext_y "# Success")"
        echo
        sleep 2
        if grep -i "error" server_log.txt >/dev/null; then
            start_true
        else
            start_false
        fi
    fi
}

function bash_testservers() {
    if [ ! -f "server.cfg" ]; then
        echo "server.cfg not found!"
        bash_end ""
    fi

    mv server.cfg server.cfg.bak

    echo -n ":: Enter gamemode name:"
    echo
    read -r -p ">>> " GAMEMODE_NAME

    awk -v new_gamemode="$GAMEMODE_NAME" '
    /^gamemode0 / {$2=new_gamemode} 1' server.cfg.bak > server.cfg

    echo "New server.cfg created with gamemode: $GAMEMODE_NAME"

    if [ ! -f "$BASH_SERVER" ]; then
        echo
        echo "# $BASH_SERVER not found.."
        BASH_SEND_SAMP_STATUS=2
        bash_send_samp
    else
        chmod 777 "$BASH_SERVER"
        ./samp03svr &
        sleep 1
        cat server_log.txt
        echo
        killall -15 "samp03svr" >/dev/null 2>&1
    fi

    rm -f server.cfg
    mv server.cfg.bak server.cfg
    echo "Original server.cfg has been restored."

    bash_end ""
}

function bash_compilers() {
    SHFILE=false
    
    while IFS= read -r -d '' pawncc; do
    if [ -f "$pawncc" ]; then
        COMPILER_PAWNCC="$pawncc"
        break
    fi
    done < <(find "$BASH_DIR" -name "pawncc" -print0)

    if [ -z "$COMPILER_PAWNCC" ]; then
        echo "# pawncc not found.."
        echo
        BASH_SEND_PAWNCC_STATUS=1
        bash_send_compiler
    fi

    mapfile -d '' files < <(find "$BASH_DIR" -name "*.io*" -type f -print0)

    for file in "${files[@]}"; do
        if [ -f "$file" ] && [[ "$file" != *.amx ]]; then
            SHFILE=true
            bash_title "$file"

            AMX_O="$(dirname "$file")/$(basename "${file%.io*}.amx")"

            echo -n "$(bash_coltext_y "info: ")"
            echo "Processing: $file"

            "$COMPILER_PAWNCC" -i"$BASH_DIR$BASH_ALLOW_SDIR" "$file" -o"$AMX_O" "$AMX_OPT_F" > "$METADAT_FILE" 2>&1
            EXIT_STATUS=$?

            if [ $EXIT_STATUS -ne 0 ] || grep -q "fatal error" "$METADAT_FILE"; then
                echo "Compilation failed with exit code: $EXIT_STATUS"
                [ -f "$AMX_O" ] && rm -rf "$AMX_O"
            fi

            _cache_compiler
            sleep 0
            cat "$METADAT_FILE"

            if [ -s "$AMX_O" ]; then
                echo
                echo "~ $AMX_O"
                if [ "$COMPILER_MODE" == "true" ]; then
                    BASH_TITLE="compilers"
                    bash_title "$SHUSERS:~/ $BASH_TITLE"
                elif [ "$COMPILER_MODE" == "false" ]; then
                    BASH_TITLE="compiler - running"
                    bash_title "$SHUSERS:~/ $BASH_TITLE"
                fi
                echo "total size : $(stat -c%s "$AMX_O") bytes"
                echo
            else
                if [ "$COMPILER_MODE" == "false" ]; then
                    bash_end ""
                fi
            fi
        fi
    done

    if [ "$SHFILE" == "false" ]; then
        echo -n "$(bash_coltext_r "..io not found!")"
        echo
        bash_end ""
    fi
    if [ "$COMPILER_MODE" == "true" ]; then
        bash_end ""
    elif [ "$COMPILER_MODE" == "false" ]; then
        ok_next
    fi
}

function _cache_compiler() {
    cache_compiler=".cache/compiler.log"
    _cache_compiler=".cache/.compiler.log"
    if [ -f "$_cache_compiler" ]; then
        rm -rf "$_cache_compiler"
    fi
    while IFS= read -r line; do
        echo "~" >> "$_cache_compiler"
        echo "$line" >> "$_cache_compiler"
    done < "$cache_compiler"
    mv "$_cache_compiler" "$cache_compiler" >/dev/null
}

function CHECK_FOL_NOW() {
    local folder=$1
    if [ -d "$folder" ]; then
        echo
        echo "# $folder is .. Ok .."
        echo " [A subdirectory or file $folder already exists.]"
        echo "-"
        sleep 1
    else
        mkdir -p "$folder"
        echo "OK? '$BASH_DIR/$folder'...: [yes]"

        cat <<EOF > gamemodes/main.io.pwn
#include <a_samp>

main() {
    print("Hello, World!");
}
EOF
        sleep 1
    fi
}

function start_true() {
    echo -n "$(bash_coltext_r "~")"
    echo "    ; \"error\"   .. Yes .. True"
    error_cache
}

function start_false() {
    echo -n "$(bash_coltext_y "~")"
    echo "    ; \"error\"   .. No .. False"
    check2
}

function check2() {
    if grep -i "failed" server_log.txt >/dev/null; then
        start_true2
    else
        start_false2
    fi
}

function start_true2() {
    echo -n "$(bash_coltext_r "~")"
    echo "    ; \"failed\"  .. Yes .. True"
    failed_cache
}

function start_false2() {
    echo -n "$(bash_coltext_y "~")"
    echo "    ; \"failed\"  .. No .. False"
    check3
}

function check3() {
    if grep -i "invalid" server_log.txt >/dev/null; then
        start_true3
    else
        start_false3
    fi
}

function start_true3() {
    echo -n "$(bash_coltext_r "~")"
    echo "    ; \"invalid\" .. Yes .. True"
    invalid_cache
}

function start_false3() {
    echo -n "$(bash_coltext_y "~")"
    echo "    ; \"invalid\" .. No .. False"
    echo
    bash_end ""
}

function error_cache() {
    echo
    grep -i "error" server_log.txt
    echo
    check2
}

function failed_cache() {
    echo
    grep -i "failed" server_log.txt
    echo
    check3
}

function invalid_cache() {
    echo
    grep -i "invalid" server_log.txt
    echo
    bash_end ""
}

function ok_next() {
    echo -n "$(bash_coltext_y "Press any key to running.")"
    echo
    read -r -n 1 -s
    bash_servers
}

function bash_send_samp()
{
    echo "Do you want to continue downloading SA-MP? (Yy/Nn)"
    read -r -p ">> " SEL_C
    if [[ "$SEL_C" =~ ^[Yy]$ ]]; then
        cd "$BASH_DIR" || bash_end ""
        echo "Select the SA-MP version to download:"
        echo "[A/a] SA-MP 0.3.7 R2-1-1"
        echo "[B/b] SA-MP 0.3.7 R3"
        echo "[C/c] SA-MP 0.3.DL R1"
        read -r -p ">> " _VERSION_
        
        while true; do
            case "$_VERSION_" in
                [Aa])
                    DOWNLOAD_URL_CURL="https://files.sa-mp.app/samp037svr_R2-2-1.tar.gz"
                    DOWNLOAD_FILE_CURL="samp037svr_R2-2-1.tar.gz"
                    break
                    ;;
                [Bb])
                    DOWNLOAD_URL_CURL="https://files.sa-mp.app/samp037svr_R3.tar.gz"
                    DOWNLOAD_FILE_CURL="samp037svr_R3.tar.gz"
                    break
                    ;;
                [Cc])
                    DOWNLOAD_URL_CURL="https://sa-mp.co.id/files/samp03DLsvr_R1.tar.gz"
                    DOWNLOAD_FILE_CURL="samp03DLsvr_R1.tar.gz"
                    break
                    ;;
                *)
                    echo -n "$(bash_coltext_r "E: ")"
                    echo "Invalid selection. Please enter A, B, or C."
                    read -r -p ">> " _VERSION_
                    ;;
            esac
        done

        echo -e "\nDownloading: $DOWNLOAD_URL_CURL -> $DOWNLOAD_FILE_CURL"
        if ! curl -L --progress-bar -o "$DOWNLOAD_FILE_CURL" "$DOWNLOAD_URL_CURL"; then
            echo -n "$(bash_coltext_r "fail: ")"
            echo "Failed to download the file.."
            
            if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
                bash_servers
            elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
                bash_testservers
            elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
                bash_end ""
            fi
        else
            tar -xzvf "$DOWNLOAD_FILE_CURL" -C "$BASH_DIR" --strip-components=1
            echo
            echo -n "$(bash_coltext_y "Download completed successfully.")"
            echo
            echo "Please rename \"rcon_password\" before running this command again"

            if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
                bash_servers
            elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
                bash_testservers
            elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
                bash_end ""
            fi
        fi
    else
        if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
            bash_servers
        elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
            bash_testservers
        elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
            bash_end ""
        fi
    fi
}

function bash_send_compiler()
{
    echo "Do you want to continue downloading PawnCC? (Yy/Nn)"
    read -r -p ">> " SEL_C
    if [[ "$SEL_C" =~ ^[Yy]$ ]]; then
        cd "$BASH_DIR" || bash_end ""
        echo "Select the PawnCC version to download:"
        echo "[A/a] PawnCC 3.10.10"
        echo "[B/b] PawnCC 3.10.9"
        echo "[C/c] PawnCC 3.10.8"
        echo "[D/d] PawnCC 3.10.7"
        echo "[E/e] PawnCC 3.10.6"
        echo "[F/f] PawnCC 3.10.5"
        read -r -p ">> " _VERSION_

        while true; do
            case "$_VERSION_" in
                [Aa])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.10/pawnc-3.10.10-linux.tar.gz"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.10-linux.tar.gz"
                    break
                    ;;
                [Bb])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.9/pawnc-3.10.9-linux.tar.gz"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.9-linux.tar.gz"
                    break
                    ;;
                [Cc])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.8/pawnc-3.10.8-linux.tar.gz"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.8-linux.tar.gz"
                    break
                    ;;
                [Dd])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.7/pawnc-3.10.7-linux.tar.gz"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.7-linux.tar.gz"
                    break
                    ;;
                [Ee])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.6/pawnc-3.10.6-linux.tar.gz"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.6-linux.tar.gz"
                    break
                    ;;
                [Ff])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.5/pawnc-3.10.5-linux.tar.gz"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.5-linux.tar.gz"
                    break
                    ;;
                *)
                    echo -n "$(bash_coltext_r "E: ")"
                    echo "Invalid selection. Please enter A, B, C, D, or E, F."
                    read -r -p ">> " _VERSION_
                    ;;
            esac
        done

        echo -e "\nDownloading: $DOWNLOAD_URL_CURL -> $DOWNLOAD_FILE_CURL"
        if ! curl -L --progress-bar -o "$DOWNLOAD_FILE_CURL" "$DOWNLOAD_URL_CURL"; then
            echo -n "$(bash_coltext_r "fail: ")"
            echo "Failed to download the file.."

            if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
                bash_compilers
            elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
                bash_end ""
            fi
        else
            tar -xzvf "$DOWNLOAD_FILE_CURL" -C "$BASH_DIR" --strip-components=1
            echo
            echo -n "$(bash_coltext_y "Download completed successfully.")"
            echo

            if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
                bash_compilers
            elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
                bash_end ""
            fi
        fi
    else
        if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
            bash_compilers
        elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
            bash_end ""
        fi
    fi
}

function bash_send_samp2()
{
    echo "Do you want to continue downloading SA-MP? (Yy/Nn)"
    read -r -p ">> " SEL_C
    if [[ "$SEL_C" =~ ^[Yy]$ ]]; then
        cd "$BASH_DIR" || bash_end ""
        echo "Select the SA-MP version to download:"
        echo "[A/a] SA-MP 0.3.7 R2-1-1"
        echo "[B/b] SA-MP 0.3.7 R3"
        echo "[C/c] SA-MP 0.3.DL R1"
        read -r -p ">> " _VERSION_

        while true; do
            case "$_VERSION_" in
                [Aa])
                    DOWNLOAD_URL_CURL="https://files.sa-mp.app/samp037_svr_R2-1-1_win32.zip"
                    DOWNLOAD_FILE_CURL="samp037_svr_R2-1-1_win32.zip"
                    break
                    ;;
                [Bb])
                    DOWNLOAD_URL_CURL="https://files.sa-mp.app/samp037_svr_R3_win32.zip"
                    DOWNLOAD_FILE_CURL="samp037_svr_R3_win32.zip"
                    break
                    ;;
                [Cc])
                    DOWNLOAD_URL_CURL="https://sa-mp.co.id/files/samp03DL_svr_R1_win32.zip"
                    DOWNLOAD_FILE_CURL="samp03DL_svr_R1_win32.zip"
                    break
                    ;;
                *)
                    echo -n "$(bash_coltext_r "E: ")"
                    echo "Invalid selection. Please enter A, B, or C."
                    read -r -p ">> " _VERSION_
                    ;;
            esac
        done

        echo -e "\nDownloading: $DOWNLOAD_URL_CURL -> $DOWNLOAD_FILE_CURL"
        if ! curl -L --progress-bar -o "$DOWNLOAD_FILE_CURL" "$DOWNLOAD_URL_CURL"; then
            echo -n "$(bash_coltext_r "fail: ")"
            echo "Failed to download the file.."

            if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
                bash_servers
            elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
                bash_testservers
            elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
                bash_end ""
            fi
        else
            unzip -q "$DOWNLOAD_FILE_CURL" -d "$BASH_DIR"
            echo
            echo -n "$(bash_coltext_y "Download completed successfully.")"
            echo
            echo "Please rename \"rcon_password\" before running this command again"

            if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
                bash_servers
            elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
                bash_testservers
            elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
                bash_end ""
            fi
        fi
    else
        if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
            bash_servers
        elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
            bash_testservers
        elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
            bash_end ""
        fi
    fi
}

function bash_send_compiler2()
{
    echo "Do you want to continue downloading PawnCC? (Yy/Nn)"
    read -r -p ">> " SEL_C
    if [[ "$SEL_C" =~ ^[Yy]$ ]]; then
        cd "$BASH_DIR" || bash_end ""
        echo "Select the PawnCC version to download:"
        echo "[A/a] PawnCC 3.10.10"
        echo "[B/b] PawnCC 3.10.9"
        echo "[C/c] PawnCC 3.10.8"
        echo "[D/d] PawnCC 3.10.7"
        echo "[E/e] PawnCC 3.10.6"
        echo "[F/f] PawnCC 3.10.5"
        read -r -p ">> " _VERSION_

        while true; do
            case "$_VERSION_" in
                [Aa])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.10/pawnc-3.10.10-windows.zip"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.10-windows.zip"
                    break
                    ;;
                [Bb])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.9/pawnc-3.10.9-windows.zip"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.9-windows.zip"
                    break
                    ;;
                [Cc])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.8/pawnc-3.10.8-windows.zip"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.8-windows.zip"
                    break
                    ;;
                [Dd])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.7/pawnc-3.10.7-windows.zip"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.7-windows.zip"
                    break
                    ;;
                [Ee])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.6/pawnc-3.10.6-windows.zip"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.6-windows.zip"
                    break
                    ;;
                [Ff])
                    DOWNLOAD_URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.5/pawnc-3.10.5-windows.zip"
                    DOWNLOAD_FILE_CURL="pawnc-3.10.5-windows.zip"
                    break
                    ;;
                *)
                    echo -n "$(bash_coltext_r "E: ")"
                    echo "Invalid selection. Please enter A, B, C, D, or E, F."
                    read -r -p ">> " _VERSION_
                    ;;
            esac
        done

        echo -e "\nDownloading: $DOWNLOAD_URL_CURL -> $DOWNLOAD_FILE_CURL"
        if ! curl -L --progress-bar -o "$DOWNLOAD_FILE_CURL" "$DOWNLOAD_URL_CURL"; then
            echo -n "$(bash_coltext_r "fail: ")"
            echo "Failed to download the file.."

            if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
                bash_compilers
            elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
                bash_end ""
            fi
        else
            unzip -q "$DOWNLOAD_FILE_CURL" -d "$BASH_DIR"
            echo
            echo -n "$(bash_coltext_y "Download completed successfully.")"
            echo

            if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
                bash_compilers
            elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
                bash_end ""
            fi
        fi
    else
        if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
            bash_compilers
        elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
            bash_end ""
        fi
    fi
}

bash_typeof ""
